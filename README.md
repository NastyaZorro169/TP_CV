# Dzhaga_CV_term_project

[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&width=1000&lines=Курсовая+работа+по+CV+Джага+Артема+и+Зориной+Анастасии)](https://git.io/typing-svg)

Вам для улыбки:

![Jokes Card](https://readme-jokes.vercel.app/api)

А теперь к серьезному: 
---
# Docker

Команды для сборки и запуска контейнера:
```
# Build
docker build -t cv-flask .
# Run
docker run -p 5000:5000 cv-flask:latest
```
---
# Описание алгоритма кода:

## Полный алгоритм работы программы

### 1. Настройка запуска приложения Flask

```python
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Flask app exposing yolov5 models")
    parser.add_argument("--port", default=5000, type=int, help="port number")
    args = parser.parse_args()

    model = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True) 
    model.eval()
    app.run(host="0.0.0.0", port=args.port) 
```

- Настраивается парсер аргументов командной строки для указания порта.
- Загружается предобученная модель YOLOv5 с использованием `torch.hub`.
- Модель переводится в режим оценки (`eval()`) (состояние, в котором модель подготавливается к выполнению предсказаний на новых данных)
- Запускается приложение Flask на указанном порту и доступно по всем интерфейсам (`host="0.0.0.0"`)

### 2. Создается экземпляр приложения Flask с именем app. Это основной объект, который управляет маршрутизацией и обработкой запросов.
Приложение обрабатывает POST и GET запросы. POST запрос нужен для отправки изображения на сервер для его обработки, GET запрос - для визуализации обработанного изображения для пользователя или исходной страницы.

``` python
app = Flask(__name__)
```

### 3.  Обработка POST запроса

3.1. Проверка на расширение файла, если он есть, осуществляется на уровне js script. Программа проверяет наличие файла в запросе. Если файлов нет, то возвращает исходную страницу
    
3.2. Если файл есть, то считываем байты загруженного файла и открываем его как изображение с помощью библиотеки Pillow

3.3. Изображение передается в модель YOLOv5 для выполнения инференции (распознавания объектов)

  ``` python
  results = model([img])
  ```
    
3.4. Переводим названия объектов, которые получили, на русский язык (мы же в России)
    
3.5. Отрисовываем на изображении название объектов, которые нашли, и их границы

  ```
  results.render() 
  ```
    
3.6. Сохраняем полученное изображение и возвращаем страничку с ним для пользователя

### 4. Обработка GET запроса
   Возвращаем исходную страницу

---
# Инструкция по применению:

Шаг 1. Зайдите на http://127.0.0.1:5000

Шаг 2. При запуске отображается слдедующий интерфейс.
![Screenshot_1](https://github.com/user-attachments/assets/49eb426c-889b-44be-ad24-0563c6a5bfd8)

Шаг 3. Далее пользователь нажимает кнопку, указанную на изображении ниже.
![image](https://github.com/user-attachments/assets/d8df3aef-4c20-4e4b-b5a7-a5cf6f282d70)

Шаг 4. Далее пользователь выбирает изображение.  
Разрешается подача изображения в формете либо `.jpg`, либо `.jpeg` размером до 1Мб.  
Если пользователь выполнил условия, приложение отображает следующий экран (изображение ниже)
![Screenshot_2](https://github.com/user-attachments/assets/ca0c92fe-f491-433b-92ff-362227daf2d0)

В области над кнопкой "Поиск" высвечивается название файла, который загрузил пользователь.  
В случае возникновения ошибок, вернитесь к шагу 3.

Шаг 5. Пользователь нажимает кнопкку "Поиск" (указана на изображении ниже)
![image](https://github.com/user-attachments/assets/72582277-28b4-49c7-ae1d-005d75fbf039)

Через несколько секунд приложение выводит следующий экран
![Screenshot_3](https://github.com/user-attachments/assets/bb3844ca-d8e3-4fed-b71d-331b58e790e8)

На нем указан класс (в данном случае это "собака") и вероятность совпадения  
с классом в процентном эквиваленте (в данном случае вероятность класса "собака" равна 0.63)

